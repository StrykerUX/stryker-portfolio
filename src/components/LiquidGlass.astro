---
// Liquid Glass WebGL Component con Three.js
export interface Props {
  className?: string;
}

const { className = '' } = Astro.props;
---

<div class={`liquid-glass-container ${className}`} data-webgl="true">
  <canvas class="liquid-glass-canvas"></canvas>
  <div class="liquid-glass-content">
    <slot />
  </div>
</div>

<style>
  .liquid-glass-container {
    position: relative;
    overflow: hidden;
  }
  
  .liquid-glass-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
  }
  
  .liquid-glass-content {
    position: relative;
    z-index: 2;
  }
  
  /* Fallback CSS para navegadores sin WebGL */
  .liquid-glass-container.no-webgl {
    background: 
      linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.1)),
      linear-gradient(45deg, rgba(255, 255, 255, 0.15), transparent 70%),
      radial-gradient(ellipse at top left, rgba(255, 255, 255, 0.3), transparent 60%);
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 
      0 8px 32px rgba(31, 38, 135, 0.15),
      inset 0 2px 0 rgba(255, 255, 255, 0.7),
      inset 0 0 20px rgba(255, 255, 255, 0.1);
  }
  
  .liquid-glass-container.no-webgl .liquid-glass-canvas {
    display: none;
  }
</style>

<script>
import * as THREE from 'three';

class LiquidGlassEffect {
  constructor(container: HTMLElement) {
    this.container = container;
    this.canvas = container.querySelector('.liquid-glass-canvas') as HTMLCanvasElement;
    
    // Crear un nuevo canvas limpio para evitar conflictos de contexto
    this.createFreshCanvas();
    
    if (!this.checkWebGLSupport()) {
      this.fallbackToCSS();
      return;
    }
    
    this.init();
  }
  
  private container: HTMLElement;
  private canvas: HTMLCanvasElement;
  private renderer?: THREE.WebGLRenderer;
  private scene?: THREE.Scene;
  private camera?: THREE.OrthographicCamera;
  private material?: THREE.ShaderMaterial;
  private mesh?: THREE.Mesh;
  private backgroundTexture?: THREE.Texture;
  private startTime = Date.now();
  private themeTransition = 0.0;
  private targetThemeTransition = 0.0;
  private isDarkMode = false;
  
  createFreshCanvas(): void {
    // Remover cualquier canvas existente
    const existingCanvas = this.container.querySelector('.liquid-glass-canvas');
    if (existingCanvas) {
      existingCanvas.remove();
    }
    
    // Crear canvas completamente nuevo, sin usar el del HTML
    this.canvas = document.createElement('canvas');
    this.canvas.className = 'liquid-glass-canvas';
    this.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      border-radius: inherit;
    `;
    
    // Insertar antes del contenido
    this.container.insertBefore(this.canvas, this.container.firstChild);
  }
  
  checkWebGLSupport(): boolean {
    try {
      // Crear un canvas temporal para test sin contaminar el principal
      const testCanvas = document.createElement('canvas');
      
      // Intentar WebGL 2 primero, luego WebGL 1 como fallback
      const context = testCanvas.getContext('webgl2') || 
                     testCanvas.getContext('webgl') || 
                     testCanvas.getContext('experimental-webgl');
      
      const supported = !!context;
      
      // Cleanup del canvas de test
      if (context) {
        const gl = context as WebGLRenderingContext;
        gl.getExtension('WEBGL_lose_context')?.loseContext();
      }
      
      return supported;
    } catch (e) {
      return false;
    }
  }
  
  fallbackToCSS(): void {
    this.container.classList.add('no-webgl');
    
    // Información detallada sobre soporte WebGL
    const canvas = document.createElement('canvas');
    const webgl1 = canvas.getContext('webgl');
    const webgl2 = canvas.getContext('webgl2');
    
    console.log('WebGL Support Report:');
    console.log('- WebGL 1:', !!webgl1);
    console.log('- WebGL 2:', !!webgl2);
    console.log('- User Agent:', navigator.userAgent);
    
    if (webgl1 && !webgl2) {
      console.warn('Este navegador solo soporta WebGL 1, pero Three.js r163+ requiere WebGL 2');
      console.warn('Considera actualizar tu navegador para mejor compatibilidad WebGL');
    }
    
    console.log('Usando CSS fallback para Liquid Glass effect');
  }
  
  init(): void {
    this.setupRenderer();
    this.setupScene();
    this.setupCamera();
    this.captureBackground();
    this.createLiquidGlassMaterial();
    this.createMesh();
    this.setupEventListeners();
    this.animate();
  }
  
  setupRenderer(): void {
    try {
      // Detectar si es un dispositivo móvil para ajustar calidad
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isLowEnd = navigator.hardwareConcurrency <= 4;
      
      // Configuración adaptativa de contexto WebGL
      const contextOptions = {
        alpha: true, 
        antialias: !isMobile, // Desactivar antialiasing en móvil
        powerPreference: isMobile ? 'default' : 'high-performance',
        preserveDrawingBuffer: false,
        stencil: false,
        depth: true,
        failIfMajorPerformanceCaveat: isMobile // Fallar si hay problemas de rendimiento en móvil
      };
      
      // Intentar WebGL 2 primero, luego WebGL 1 como fallback
      const gl = this.canvas.getContext('webgl2', contextOptions) || 
                 this.canvas.getContext('webgl', contextOptions) || 
                 this.canvas.getContext('experimental-webgl', contextOptions);
      
      if (!gl) {
        throw new Error('No se pudo obtener contexto WebGL');
      }
      
      // Verificar qué versión de WebGL tenemos
      const isWebGL2 = gl instanceof WebGL2RenderingContext;
      console.log(`WebGL ${isWebGL2 ? '2' : '1'} Context created successfully:`, gl.constructor.name);
      console.log(`Device: ${isMobile ? 'Mobile' : 'Desktop'}, CPU cores: ${navigator.hardwareConcurrency}`);
      
      // Crear renderer con el contexto obtenido
      this.renderer = new THREE.WebGLRenderer({
        context: gl,
        canvas: this.canvas
      });
      
      // Configuraciones de performance adaptativas
      const pixelRatioLimit = isMobile ? 1.5 : 2; // Menor resolución en móvil
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, pixelRatioLimit));
      
      // Solo usar SRGBColorSpace si es WebGL 2 y no es dispositivo de gama baja
      if (isWebGL2 && !isLowEnd) {
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
      }
      
      this.updateSize();
      
      console.log(`Three.js Renderer initialized with optimizations for ${isMobile ? 'mobile' : 'desktop'}`);
    } catch (error) {
      console.error('WebGL renderer failed to initialize:', error);
      this.fallbackToCSS();
      return;
    }
  }
  
  setupScene(): void {
    this.scene = new THREE.Scene();
  }
  
  setupCamera(): void {
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  }
  
  updateSize(): void {
    const rect = this.container.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    
    this.renderer?.setSize(width, height);
    this.renderer?.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  }
  
  captureBackground(): void {
    const rect = this.container.getBoundingClientRect();
    
    // Validar dimensiones mínimas
    const width = Math.max(rect.width, 1);
    const height = Math.max(rect.height, 1);
    
    if (width < 1 || height < 1) {
      console.warn('Container dimensions too small for texture:', { width, height });
      return;
    }
    
    // Crear un canvas temporal para capturar el fondo
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    if (!tempCtx) {
      console.error('No se pudo obtener contexto 2D para captura de fondo');
      return;
    }
    
    // Establecer dimensiones válidas
    tempCanvas.width = width;
    tempCanvas.height = height;
    
    // Verificar que las dimensiones se establecieron correctamente
    if (tempCanvas.width === 0 || tempCanvas.height === 0) {
      console.error('Canvas dimensions are zero after setting:', tempCanvas.width, tempCanvas.height);
      return;
    }
    
    try {
      // Crear un fondo procedural más elaborado
      const isDark = document.documentElement.classList.contains('dark');
      
      // Fondo base NEUTRO para elegancia consistente
      if (isDark) {
        tempCtx.fillStyle = '#1a1a1a'; // Gris neutro oscuro - elimina agresividad del azul
      } else {
        tempCtx.fillStyle = '#ffffff'; // Blanco puro
      }
      tempCtx.fillRect(0, 0, width, height);
      
      // GRADIENTES DE PROFUNDIDAD para efecto de vidrio grueso
      
      // Gradiente principal con efecto de profundidad
      const depthGradient = tempCtx.createRadialGradient(
        width * 0.5, height * 0.5, 0,
        width * 0.5, height * 0.5, Math.max(width, height) * 0.8
      );
      
      if (isDark) {
        // MUCH MORE SUBTLE - similar opacity range to light mode
        depthGradient.addColorStop(0, 'rgba(255, 255, 255, 0.08)'); // Reducido de 0.2 a 0.08
        depthGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.05)'); // Reducido de 0.12 a 0.05
        depthGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.03)'); // Reducido de 0.06 a 0.03
        depthGradient.addColorStop(1, 'rgba(255, 255, 255, 0.01)'); // Reducido de 0.02 a 0.01
      } else {
        depthGradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
        depthGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.06)');
        depthGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.03)');
        depthGradient.addColorStop(1, 'rgba(0, 0, 0, 0.01)');
      }
      
      tempCtx.fillStyle = depthGradient;
      tempCtx.fillRect(0, 0, width, height);
      
      // Gradientes de esquina para simular grosor de vidrio
      const cornerGradients = [
        { x: 0, y: 0, size: 0.4 }, // Top-left
        { x: width, y: 0, size: 0.3 }, // Top-right  
        { x: 0, y: height, size: 0.3 }, // Bottom-left
        { x: width, y: height, size: 0.35 } // Bottom-right
      ];
      
      cornerGradients.forEach(corner => {
        const cornerGrad = tempCtx.createRadialGradient(
          corner.x, corner.y, 0,
          corner.x, corner.y, Math.min(width, height) * corner.size
        );
        
        if (isDark) {
          // MUCH MORE SUBTLE corner gradients - matching light mode elegance
          cornerGrad.addColorStop(0, 'rgba(255, 255, 255, 0.06)'); // Reducido de 0.15 a 0.06
          cornerGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.03)'); // Reducido de 0.08 a 0.03
          cornerGrad.addColorStop(1, 'transparent');
        } else {
          cornerGrad.addColorStop(0, 'rgba(0, 0, 0, 0.08)');
          cornerGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.04)');
          cornerGrad.addColorStop(1, 'transparent');
        }
        
        tempCtx.fillStyle = cornerGrad;
        tempCtx.fillRect(0, 0, width, height);
      });
      
      // PATRÓN GEOMÉTRICO para mejor tracking de distorsión - más sutil en dark mode
      tempCtx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.04)' : 'rgba(0, 0, 0, 0.05)'; // Reducido de 0.1 a 0.04
      tempCtx.lineWidth = 1;
      
      // Grid pattern para ver la distorsión claramente
      for (let x = 0; x < width; x += 40) {
        tempCtx.beginPath();
        tempCtx.moveTo(x, 0);
        tempCtx.lineTo(x, height);
        tempCtx.stroke();
      }
      
      for (let y = 0; y < height; y += 40) {
        tempCtx.beginPath();
        tempCtx.moveTo(0, y);
        tempCtx.lineTo(width, y);
        tempCtx.stroke();
      }
      
      // Noise pattern sutil
      const imageData = tempCtx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * (isDark ? 3 : 4); // Reducido de 8 a 3 para dark mode
        data[i] += noise;     // R
        data[i + 1] += noise; // G
        data[i + 2] += noise; // B
      }
      
      tempCtx.putImageData(imageData, 0, 0);
      
      // Limpiar textura anterior si existe
      if (this.backgroundTexture) {
        this.backgroundTexture.dispose();
      }
      
      // Crear textura de Three.js con validaciones
      this.backgroundTexture = new THREE.CanvasTexture(tempCanvas);
      this.backgroundTexture.wrapS = THREE.ClampToEdgeWrapping;
      this.backgroundTexture.wrapT = THREE.ClampToEdgeWrapping;
      this.backgroundTexture.minFilter = THREE.LinearFilter;
      this.backgroundTexture.magFilter = THREE.LinearFilter;
      this.backgroundTexture.generateMipmaps = false;
      
      // Forzar actualización de la textura
      this.backgroundTexture.needsUpdate = true;
      
      console.log('Background texture created:', width, 'x', height);
      
    } catch (error) {
      console.error('Error creating background texture:', error);
    }
  }
  
  createLiquidGlassMaterial(): void {
    // Verificar que tenemos una textura válida
    if (!this.backgroundTexture) {
      console.error('No background texture available for material');
      return;
    }
    
    // Detectar dispositivo para ajustar calidad del shader
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isLowEnd = navigator.hardwareConcurrency <= 4;
    
    const vertexShader = `
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const fragmentShader = `
      uniform sampler2D uBackground;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uDistortionStrength;
      uniform float uThemeTransition; // 0.0 = light, 1.0 = dark
      uniform vec3 uBaseColor;
      uniform vec3 uHighlightColor;
      
      varying vec2 vUv;
      
      // Función de ruido procedural
      float noise(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }
      
      // Función de ruido suave
      float smoothNoise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        
        float a = noise(i);
        float b = noise(i + vec2(1.0, 0.0));
        float c = noise(i + vec2(0.0, 1.0));
        float d = noise(i + vec2(1.0, 1.0));
        
        vec2 u = f * f * (3.0 - 2.0 * f);
        
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      
      // Función de ruido fractal
      float fbm(vec2 st) {
        float value = 0.0;
        float amplitude = 0.5;
        
        for (int i = 0; i < 3; i++) {
          value += amplitude * smoothNoise(st);
          st *= 2.0;
          amplitude *= 0.5;
        }
        
        return value;
      }
      
      // Función para calcular la distancia a los bordes
      float edgeDistance(vec2 uv) {
        vec2 d = abs(uv - 0.5) * 2.0; // Normalizar a [0,1] desde el centro
        return min(1.0 - max(d.x, d.y), 1.0); // Distancia a los bordes
      }
      
      // Función para efecto de grosor de vidrio
      float glassThickness(vec2 uv) {
        float edge = edgeDistance(uv);
        return smoothstep(0.7, 1.0, edge); // Solo en los bordes
      }
      
      void main() {
        vec2 uv = vUv;
        
        // CÁLCULO DE PROFUNDIDAD DE VIDRIO
        float edge = edgeDistance(uv);
        float thickness = glassThickness(uv);
        float centerToEdge = 1.0 - edge; // Mayor en los bordes
        
        // LIQUID GLASS DRAMÁTICO - más intenso en bordes
        float time = uTime * 1.2;
        
        // ONDAS CON INTENSIDAD BASADA EN PROFUNDIDAD
        float waveIntensity = 1.0 + centerToEdge * 2.0; // 3x más fuerte en bordes
        float wave1 = sin(uv.x * 3.0 + time * 2.0) * 0.05 * waveIntensity;
        float wave2 = sin(uv.y * 2.5 + time * 1.8) * 0.04 * waveIntensity;
        float wave3 = sin((uv.x + uv.y) * 4.0 + time * 2.5) * 0.03 * waveIntensity;
        float wave4 = sin((uv.x - uv.y) * 5.0 + time * 1.5) * 0.025 * waveIntensity;
        
        // DISTORSIÓN DE BORDES - EFECTO VIDRIO CURVADO
        vec2 borderDistortion = vec2(0.0);
        
        // Distorsión horizontal en bordes izquierdo/derecho
        if (uv.x < 0.1) {
          float edgeStrength = (0.1 - uv.x) * 10.0; // Más fuerte cerca del borde
          borderDistortion.x += sin(uv.y * 8.0 + time * 2.0) * 0.02 * edgeStrength;
          borderDistortion.y += cos(uv.y * 6.0 + time * 1.5) * 0.015 * edgeStrength;
        }
        if (uv.x > 0.9) {
          float edgeStrength = (uv.x - 0.9) * 10.0;
          borderDistortion.x -= sin(uv.y * 8.0 + time * 2.0) * 0.02 * edgeStrength;
          borderDistortion.y += cos(uv.y * 6.0 + time * 1.5) * 0.015 * edgeStrength;
        }
        
        // Distorsión vertical en bordes superior/inferior
        if (uv.y < 0.1) {
          float edgeStrength = (0.1 - uv.y) * 10.0;
          borderDistortion.y += sin(uv.x * 8.0 + time * 2.2) * 0.02 * edgeStrength;
          borderDistortion.x += cos(uv.x * 6.0 + time * 1.7) * 0.015 * edgeStrength;
        }
        if (uv.y > 0.9) {
          float edgeStrength = (uv.y - 0.9) * 10.0;
          borderDistortion.y -= sin(uv.x * 8.0 + time * 2.2) * 0.02 * edgeStrength;
          borderDistortion.x += cos(uv.x * 6.0 + time * 1.7) * 0.015 * edgeStrength;
        }
        
        // LIQUID RIPPLES - más intensos en bordes
        vec2 center1 = vec2(0.3, 0.7);
        vec2 center2 = vec2(0.7, 0.3);
        float dist1 = length(uv - center1);
        float dist2 = length(uv - center2);
        
        float ripple1 = sin(dist1 * 15.0 - time * 3.0) * exp(-dist1 * 2.0) * 0.04 * waveIntensity;
        float ripple2 = sin(dist2 * 12.0 - time * 2.5) * exp(-dist2 * 1.8) * 0.035 * waveIntensity;
        
        // RUIDO LÍQUIDO ORGÁNICO - más denso en bordes
        float liquidNoise = fbm(uv * 1.5 + time * 0.3) * 0.06 * waveIntensity;
        
        // DISTORSIÓN COMBINADA CON EFECTOS DE BORDE
        vec2 distortion = vec2(
          wave1 + wave3 + ripple1 + liquidNoise,
          wave2 + wave4 + ripple2 + liquidNoise * 0.9
        ) * uDistortionStrength * 3.0 + borderDistortion;
        
        // Aplicar distorsión final
        vec2 distortedUV = uv + distortion;
        
        // REFRACCIÓN INTENSIFICADA EN BORDES
        float aberration = 0.008 * uDistortionStrength * (1.0 + centerToEdge * 2.0);
        
        // Muestreo con aberración cromática más pronunciada en bordes
        vec3 mainSample = texture2D(uBackground, distortedUV).rgb;
        float r = texture2D(uBackground, distortedUV + vec2(aberration, 0.0)).r;
        float g = texture2D(uBackground, distortedUV + vec2(aberration * 0.5, aberration * 0.3)).g;
        float b = texture2D(uBackground, distortedUV - vec2(aberration, 0.0)).b;
        
        // Mix más pronunciado en los bordes para mejor efecto de profundidad
        float refractionMix = 0.3 + centerToEdge * 0.4; // Hasta 0.7 en bordes
        vec3 refractionColor = mix(mainSample, vec3(r, g, b), refractionMix);
        
        // FRESNEL INTENSIFICADO EN BORDES para profundidad
        vec3 normal = normalize(vec3(uv - 0.5, 0.2 + thickness * 0.5));
        float fresnel = pow(1.0 - abs(dot(normal, vec3(0.0, 0.0, 1.0))), 2.0 + centerToEdge * 2.0);
        fresnel *= 0.8 + centerToEdge * 0.4; // Más intenso en bordes
        
        // LIQUID SURFACE HIGHLIGHTS - más visibles en bordes
        float surface1 = sin(time * 1.5 + uv.x * 12.0) * sin(time * 1.8 + uv.y * 10.0);
        float surface2 = sin(time * 0.8 + (uv.x + uv.y) * 8.0);
        float surface3 = fbm(uv * 4.0 + time * 0.4);
        
        float highlight = (surface1 * surface2 * surface3) * (0.3 + centerToEdge * 0.3) + 0.2;
        highlight = smoothstep(0.0, 1.0, highlight);
        
        // CAUSTICS INTENSIFICADOS EN BORDES
        float caustic1 = sin(uv.x * 20.0 + time * 2.0) * sin(uv.y * 15.0 + time * 1.7);
        float caustic2 = sin((uv.x + uv.y) * 25.0 + time * 2.5);
        float caustics = (caustic1 * caustic2) * (0.15 + centerToEdge * 0.2);
        caustics = smoothstep(0.5, 1.0, caustics + 0.5);
        
        // EFECTO DE GROSOR DE VIDRIO EN BORDES
        float glassHighlight = smoothstep(0.8, 1.0, edge) * 0.4; // Brillo en los bordes
        
        // COLOR FINAL CON PROFUNDIDAD Y TRANSICIÓN DE TEMA - más elegante en dark mode
        vec3 lightHighlight = vec3(1.0, 1.0, 1.0); // Blanco puro para light mode
        vec3 darkHighlight = vec3(0.15, 0.16, 0.17); // Gris muy oscuro con ligero tinte para dark mode
        vec3 currentHighlight = mix(lightHighlight, darkHighlight, uThemeTransition);
        
        // Intensidad de efectos más sutil en dark mode
        float effectIntensity = mix(0.4, 0.25, uThemeTransition); // Reducir intensidad en dark mode
        
        // Aplicar todos los efectos con intensidad adaptativa
        vec3 finalColor = mix(
          refractionColor, 
          currentHighlight, 
          (highlight + fresnel + caustics + glassHighlight) * effectIntensity
        );
        
        // Brillo de superficie más pronunciado en bordes
        float gloss = sin(time * 0.5 + uv.x * 8.0) * sin(time * 0.7 + uv.y * 6.0) * 0.1 + 0.1;
        gloss *= smoothstep(0.4, 0.6, fbm(uv * 2.0 + time * 0.1));
        gloss *= 1.0 + centerToEdge * 0.5; // Más gloss en bordes
        
        // Color del brillo más sutil en dark mode
        vec3 lightGloss = vec3(1.0, 1.0, 1.0); // Blanco puro para light mode
        vec3 darkGloss = vec3(0.12, 0.13, 0.14); // Negro claro con ligero tinte para dark mode
        vec3 currentGloss = mix(lightGloss, darkGloss, uThemeTransition);
        
        // Intensidad de gloss más sutil en dark mode
        float glossIntensity = mix(0.3, 0.15, uThemeTransition); // Reducir en dark mode
        finalColor = mix(finalColor, currentGloss, gloss * fresnel * glossIntensity);
        
        // Alpha más consistente entre temas
        float baseAlpha = mix(0.88, 0.85, uThemeTransition); // Menos diferencia entre temas
        float depthAlpha = baseAlpha + fresnel * 0.15 + centerToEdge * 0.08; // Efecto más sutil en bordes
        
        gl_FragColor = vec4(finalColor, depthAlpha);
      }
    `;
    
    try {
      this.material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uBackground: { value: this.backgroundTexture },
          uTime: { value: 0.0 },
          uResolution: { value: new THREE.Vector2() },
          uDistortionStrength: { value: isMobile ? 1.8 : 2.5 }, // Reducir en móvil para mejor performance
          uThemeTransition: { value: 0.0 }, // 0.0 = light, 1.0 = dark
          uBaseColor: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
          uHighlightColor: { value: new THREE.Vector3(1.0, 1.0, 1.0) }
        },
        transparent: true,
        blending: THREE.NormalBlending,
        side: THREE.DoubleSide,
        depthWrite: false, // Mejor blending para efecto de vidrio
        depthTest: true
      });
      
      console.log('Liquid glass material created successfully');
    } catch (error) {
      console.error('Error creating shader material:', error);
    }
  }
  
  createMesh(): void {
    if (!this.material) {
      console.error('No material available for mesh creation');
      return;
    }
    
    if (!this.scene) {
      console.error('No scene available for mesh creation');
      return;
    }
    
    try {
      const geometry = new THREE.PlaneGeometry(2, 2);
      this.mesh = new THREE.Mesh(geometry, this.material);
      this.scene.add(this.mesh);
      
      console.log('Mesh created and added to scene successfully');
    } catch (error) {
      console.error('Error creating mesh:', error);
    }
  }
  
  setupEventListeners(): void {
    window.addEventListener('resize', () => this.updateSize());
    
    // Actualizar fondo en scroll
    let scrollTimeout: number;
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = window.setTimeout(() => {
        this.captureBackground();
        if (this.material) {
          this.material.uniforms.uBackground.value = this.backgroundTexture;
        }
      }, 100);
    });
    
    // Theme change handler con transición suave
    const observer = new MutationObserver(() => {
      this.handleThemeChange();
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
    
    // Inicializar estado del tema
    this.handleThemeChange();
  }
  
  handleThemeChange(): void {
    const isDark = document.documentElement.classList.contains('dark');
    
    if (isDark !== this.isDarkMode) {
      this.isDarkMode = isDark;
      this.targetThemeTransition = isDark ? 1.0 : 0.0;
      
      // También actualizar el fondo
      setTimeout(() => {
        this.captureBackground();
        if (this.material) {
          this.material.uniforms.uBackground.value = this.backgroundTexture;
        }
      }, 50);
      
      console.log(`Theme changed to: ${isDark ? 'dark' : 'light'}, transitioning to: ${this.targetThemeTransition}`);
    }
  }
  
  updateThemeTransition(): void {
    // Transición suave con easing
    const speed = 0.02; // Velocidad de transición (ajustable)
    const diff = this.targetThemeTransition - this.themeTransition;
    
    if (Math.abs(diff) > 0.001) {
      this.themeTransition += diff * speed;
      
      // Actualizar uniform del shader
      if (this.material && this.material.uniforms) {
        this.material.uniforms.uThemeTransition.value = this.themeTransition;
      }
    } else {
      // Snap al valor final cuando está muy cerca
      this.themeTransition = this.targetThemeTransition;
      if (this.material && this.material.uniforms) {
        this.material.uniforms.uThemeTransition.value = this.themeTransition;
      }
    }
  }
  
  animate = (): void => {
    // Validar que todos los componentes están disponibles
    if (!this.renderer || !this.scene || !this.camera) {
      console.warn('Renderer, scene, or camera not available for animation');
      return;
    }
    
    try {
      const currentTime = (Date.now() - this.startTime) * 0.001;
      
      // Actualizar transición de tema en cada frame
      this.updateThemeTransition();
      
      if (this.material && this.material.uniforms) {
        this.material.uniforms.uTime.value = currentTime;
        
        const rect = this.container.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          this.material.uniforms.uResolution.value.set(rect.width, rect.height);
        }
      }
      
      this.renderer.render(this.scene, this.camera);
      requestAnimationFrame(this.animate);
    } catch (error) {
      console.error('Animation error:', error);
      // Intentar una vez más después de un breve delay
      setTimeout(() => requestAnimationFrame(this.animate), 100);
    }
  };
  
  destroy(): void {
    this.renderer?.dispose();
    this.material?.dispose();
    this.backgroundTexture?.dispose();
  }
}

// Prevent duplicate initialization
const initializeWebGL = () => {
  const containers = document.querySelectorAll('[data-webgl="true"]:not([data-webgl-initialized])') as NodeListOf<HTMLElement>;
  
  containers.forEach(container => {
    try {
      container.setAttribute('data-webgl-initialized', 'true');
      new LiquidGlassEffect(container);
    } catch (error) {
      console.warn('Failed to initialize WebGL effect:', error);
      container.classList.add('no-webgl');
    }
  });
};

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeWebGL);
} else {
  initializeWebGL();
}

// Cleanup en navegación SPA
document.addEventListener('astro:before-swap', () => {
  // Reset initialization flags for next page
  document.querySelectorAll('[data-webgl-initialized]').forEach(el => {
    el.removeAttribute('data-webgl-initialized');
  });
});
</script>